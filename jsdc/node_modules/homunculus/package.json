{
  "name": "homunculus",
  "version": "0.2.6-3",
  "description": "A lexer&parser by Javascript",
  "maintainers": [
    {
      "name": "army8735",
      "email": "army8735@qq.com"
    }
  ],
  "scripts": {
    "test": "make test"
  },
  "config": {
    "blanket": {
      "pattern": [
        "src/lexer/Lexer",
        "src/lexer/Token",
        "src/lexer/match",
        "src/lexer/rule/Rule",
        "src/lexer/rule/EcmascriptRule",
        "src/parser/js",
        "src/parser/es6",
        "src/parser/Parser",
        "src/parser/Node"
      ]
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/army8735/homunculus.git"
  },
  "keywords": [
    "lexer",
    "parser",
    "javascript"
  ],
  "author": {
    "name": "army8735"
  },
  "license": "MIT",
  "dependencies": {},
  "main": "./index",
  "spm": {
    "main": "./index"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "readmeFilename": "README.md",
  "devDependencies": {
    "blanket": "^1.1.6",
    "coveralls": "^2.10.0",
    "expect.js": "^0.3.1",
    "gulp": "^3.6.0",
    "gulp-clean": "^0.2.4",
    "gulp-util": "^2.2.14",
    "mocha": "^1.18.2",
    "mocha-lcov-reporter": "0.0.1",
    "through2": "^0.4.2"
  },
  "readme": "# A lexer&parser by Javascript\n\n[![NPM version](https://badge.fury.io/js/homunculus.png)](https://npmjs.org/package/homunculus)\n[![Build Status](https://travis-ci.org/army8735/homunculus.svg?branch=master)](https://travis-ci.org/army8735/homunculus)\n[![Coverage Status](https://coveralls.io/repos/army8735/homunculus/badge.png)](https://coveralls.io/r/army8735/homunculus)\n[![Dependency Status](https://david-dm.org/army8735/homunculus.png)](https://david-dm.org/army8735/homunculus)\n\n## INSTALL\n```\nnpm install homunculus\n```\n\n## 使用说明\n* 解析语法并返回语法树和此法单元序列。\n* CommonJS/AMD/CMD自适应。\n\n## API\n### Homunculus\n* getClass(type:String, lan:String):class\n  * type:\n    * lexer \n    * parser\n    * node\n    * context\n    * token\n  * lan: \n    * js\n    * javascript\n    * es \n    * es5\n    * ecmascript\n    * es6\n    * as\n    * actionscript\n    * css\n* getLexer(lan:String):lexer/Lexer\n * lan:\n   * js\n   * javascript\n   * es\n   * es5\n   * ecmascript\n   * es6\n   * as\n   * actionscript\n   * css\n   * java\n   * c++\n   * cpp\n   * cplusplus\n* getParser(lan:String):parser/Parser\n  * lan:\n    * js\n    * javascript\n    * es\n    * es5\n    * ecmascript\n    * es6\n    * css\n* getContext(lan:String):parser/Context\n  * lan:\n    * js\n    * javascript\n    * es\n    * es5\n    * ecmascript\n\n### lexer/Lexer\n#### 方法\n* constructor(Rule:lexer/rule/Rule) 传入语法规则Rule\n* parse(code:String):Array<lexer/Token> 传入代码并返回解析后的此法单元token列表\n* tokens():Array<lexer/Token> 返回已解析好的此番单元token列表\n* cache(line:init):void 设置缓冲解析行，每次最多解析几行代码，防止code过大卡死\n* finish():Boolean 设置cache有用，当前是否解析完毕\n* line():int code有多少行\n* col():int code最大列是多少\n\n#### 静态属性\n* STRICT: 0 严格模式语法错误后抛出异常\n* LOOSE: 1 宽松模式错误后忽略\n* mod(type:int):int 读取/设置模式\n\n### parser/Parser\n#### 方法\n* constructor(lexer:Lexer) 传入词法分析器\n* parse(code:String):Node 传入代码解析并返回语法树\n* ast():Node 返回已解析好的语法树\n* ignore():Node 返回解析中被忽略掉的空白注释等内容\n\n### lexer/Token\n#### 方法\n* constructor(type:int, content:String, val:String, sIndex:int) 构造函数传入token的类型、内容、字面内容和在代码中的开始字符索引\n* type(t:int):int 读取/设置类型\n* content(c:Stirng):String 读取/设置内容\n* val(v:String):String 读取/设置字面内容，字面内容不同于内容之处在于是否包含引号\n* tag(t:int):String 读取/设置类型，返回的是类型额字符串形式\n* tid(t:int):int 读取/设置token索引，默认所有token自增形式添加索引\n* sIndex(i:int):int 读取/设置token在code中的字符索引\n\n#### 静态属性\n* type(t:int):String 返回类型的字符串形式\n\n### parser/Node\n#### 方法\n* constructor(type:String, children:Node/Array<Node> = null) 传入类型和子节点\n* name(t:String):String 读取/设置节点类型\n* leaves():Array<Node> 返回子节点列表\n* leaf(i:int):Node 返回第i个子节点\n* size():int 返回有几个子节点\n* first():Node 返回第一个子节点\n* last():Node 返回最后一个子节点\n* isEmpty():Boolean 返回是否没有子节点\n* add(...node:Node):void 添加若干个子节点\n* token():Token 实际同leaves()一样，不过当name()为Token时children存储的是终结符Token\n* parent():Node 返回父节点\n* prev():Node 返回兄弟前一个节点\n* next():Node 返回兄弟后一个节点\n\n## AST\n当调用语法分析器解析后，会返回生成ast，这是一个树状数据结构，每个节点都是对应语法解析器目录下的Node.js的实例。<br/>\ndemo目录下是一个用js的parser分析输入js代码并画出ast形状的页面。\n\n## License\n[MIT License]",
  "bugs": {
    "url": "https://github.com/army8735/homunculus/issues"
  },
  "homepage": "https://github.com/army8735/homunculus",
  "_id": "homunculus@0.2.6-3",
  "_shasum": "b8e5d46b3e620f631e09d3ab630eac92d63a000a",
  "_from": "homunculus@^0.2.6-3"
}
